## 二叉树

知识点要求

* 实现一个二叉查找树, 并支持插入, 删除, 查找操作
* 实现查找二叉查找树中某个节点的后继, 前驱节点
* 实现二叉树前, 中, 后序以及按层遍历


### 知识详解

二叉树: 每个节点最多有两个子节点. 分别为左子节点和右子节点.

> 注意: 二叉树并不要求每个节点都必须有两个子节点, 只是要求最多有两个子节点.

根据一个节点多少的特点. 二叉树中有两个特殊的树. 满二叉树和完全二叉树.

满二叉树: 除了叶子节点外的节点都有左右两个子节点.

完全二叉树: 1. 最后一层叶子节点全部靠左排列; 2. 除最后一层, 其他层节点个数都要达到最大.

满二叉树和完全二叉树适合使用数组存储, 特别是满二叉树.

我们使用数组下标1开始存储节点, 那么存储特点为:

1. 一个下标为 n 的节点, 它的左子节点为下标为 2n, 右子节点下标为 2n+1.
2. 一个下标为 n 的节点, 它的父节点下标为 n/2.

> 注意以上特点是基于从下标1开始存储节点

当使用下标0开始存储节点, 那么特点就要变了.(记忆方法: 子加父减)

1. 左子节点: 2n+1, 右子节点: 2n+2
2. 父子节点: (n-1)/2

> 堆结构就是一种完全二叉树

二叉树的遍历: 前序, 中序, 后序, 按层遍历

前序: 自己 -> 左子节点 -> 右子节点
中序: 左子节点 -> 自己 -> 右子节点 (重点: 中序遍历可以输出从小到大排列好的数据)
后序: 左子节点 -> 右子节点 -> 自己

> 以上三种遍历都是递归的过程.
> 记忆方法: 先左后右的顺序不变, 将自己插入左右前面为前序, 插入中间为中序, 插入最后为后序 

按层遍历: 通过队列实现, 先将root节点入队列, 在把root的左右子节点入队, 在把左右子节点的全部子节点入队...以此类推.

二叉查找树: 在二叉树的基础上要求任意节点, 它的左子节点比它小, 它的右子节点比它大.

推论: 
* 任意节点的左侧节点都比自己小
* 任意节点的右侧节点都比自己大

二叉查找树支持: 插入, 查找, 删除, 获取最大节点, 最小节点, 一个节点的前驱节点, 后继节点.

支持重复数据的二叉查找树

* 方法1: 每个节点用链表存储数据, 相同值的数据放入链表中;
* 方法2: 将右子节点作为相同值的节点, 不过查找时, 需要一直向右查找, 直到叶子节点或值不相同为止.

问题: 二叉查找树对比散列表有什么优势?

1, 散列表是无序的, 如果要输出有序的数据, 需要先进行排序. 而对于二叉查找树, 只需要中序遍历.
2. 散列表扩容耗时, 遇到散列冲突时, 性能不稳定. 而使用平衡二叉查找树, 可以得到非常稳定的性能.
3. 散列表查找的O(1), 并不一定比二叉查找树快, 比如hash冲突严重的时候.
4. 散列表的构造比二叉查找树复杂, 要考虑的东西多, 
   比如hash函数的设计, hash冲突解决方法, 如何扩容, 缩容等. 而二叉查找树只需要考虑平衡性问题.


## LeeCode相关习题

* 226. [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)
    
难度: 简单

* 104. [二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)
    
难度: 简单

* 98. [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)
    
难度: 中等

* 112. [路径总和](https://leetcode-cn.com/problems/path-sum/)
   
难度: 简单